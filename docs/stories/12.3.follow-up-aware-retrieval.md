# Story 12.3: Follow-up Aware Retrieval

## Status

Draft

## Story

**As a** user interacting with the chat system,
**I want** the system to correctly interpret ambiguous follow-up questions like "what do I need to submit for this?" by reusing section context from previous turns,
**so that** I receive accurate, grounded answers without having to repeat section IDs in every question.

## Acceptance Criteria

1. ChatOrchestrator helper `_extract_section_id()` implemented to detect section ID patterns (e.g., 5.22.3) in text
2. ChatOrchestrator helper `_is_ambiguous_followup()` implemented to detect short queries with pronouns/phrases that lack explicit section IDs
3. ChatOrchestrator helper `_get_last_section_id_from_history()` implemented to find the most recent section ID from chat history
4. ChatOrchestrator helper `_build_retrieval_query()` implemented to augment ambiguous follow-up queries with section context from history
5. Chat API route updated to use augmented retrieval query for retrieval while preserving original user message for LLM
6. Retrieval query augmentation only applies when current message is ambiguous and history contains a section ID
7. Original user message always passed to LLM (retrieval query augmentation is transparent to user)
8. Existing section-ID direct path in HybridSearchService continues to work unchanged
9. No changes to public API routes or request/response schemas
10. Existing multi-turn chat history mechanism (ChatSession/ChatMessage) remains intact
11. Unit tests for all helper methods (\_extract_section_id, \_is_ambiguous_followup, \_get_last_section_id_from_history, \_build_retrieval_query)
12. Integration test verifying ambiguous follow-up correctly retrieves chunks from previous section context

## Tasks / Subtasks

- [ ] Implement `_extract_section_id()` helper (AC: 1)
  - [ ] Add private method to ChatOrchestrator: `_extract_section_id(text: str) -> Optional[str]`
  - [ ] Use regex pattern: `r'\d+(?:\.\d+)+'` (same as HybridSearchService)
  - [ ] Return first match as string, or None if no match
  - [ ] Add unit tests for various section ID patterns (5.22.3, 1.2, 10.5.3.2, etc.)
  - [ ] Add unit tests for text without section IDs
- [ ] Implement `_is_ambiguous_followup()` helper (AC: 2)
  - [ ] Add private method to ChatOrchestrator: `_is_ambiguous_followup(query: str) -> bool`
  - [ ] Lowercase the query for comparison
  - [ ] Check if query length < 80 characters OR token count < ~15
  - [ ] Check if query contains pronouns/phrases: "this", "that", "it", "them", "those", "for this", "for that", "for it", "for these", "for those"
  - [ ] Check if query does NOT contain explicit section ID (use \_extract_section_id)
  - [ ] Return True only if all conditions hold
  - [ ] Add unit tests for ambiguous follow-ups ("what do I need to submit for this?", "what are the indicators for it?")
  - [ ] Add unit tests for non-ambiguous queries ("explain section 5.22.3", "give me an overview")
- [ ] Implement `_get_last_section_id_from_history()` helper (AC: 3)
  - [ ] Add private method to ChatOrchestrator: `_get_last_section_id_from_history(history_messages: list[dict]) -> Optional[str]`
  - [ ] Iterate backwards through history_messages
  - [ ] Only consider messages where role == "user"
  - [ ] For each user message, call \_extract_section_id on content
  - [ ] Return first non-None section ID found
  - [ ] Return None if no section ID found in history
  - [ ] Add unit tests for history with section IDs
  - [ ] Add unit tests for history without section IDs
  - [ ] Add unit tests for empty history
- [ ] Implement `_build_retrieval_query()` helper (AC: 4)
  - [ ] Add private method to ChatOrchestrator: `_build_retrieval_query(history_messages: list[dict], current_user_message: str) -> str`
  - [ ] If current message has explicit section ID → return unchanged
  - [ ] If not ambiguous follow-up → return unchanged
  - [ ] If ambiguous follow-up:
    - [ ] Get last section ID from history using \_get_last_section_id_from_history
    - [ ] If section ID exists → return: `f"For section {last_section}, {current_user_message}"`
    - [ ] If no section ID found → return unchanged
  - [ ] Add unit tests for various scenarios (explicit section, ambiguous with history, ambiguous without history, non-ambiguous)
- [ ] Update Chat API route to use augmented retrieval query (AC: 5)
  - [ ] Load history before retrieval (using ChatOrchestrator.load_history)
  - [ ] Build retrieval query using \_build_retrieval_query(history, current_user_message)
  - [ ] Use retrieval_query for retrieve_candidates() call
  - [ ] Continue using original user message for rerank() and chat() calls
  - [ ] Ensure original user message is preserved for LLM context
  - [ ] Add logging for retrieval query augmentation (INFO level)
- [ ] Verify retrieval query augmentation logic (AC: 6)
  - [ ] Test that augmentation only occurs for ambiguous follow-ups
  - [ ] Test that augmentation requires history with section ID
  - [ ] Test that explicit section IDs in current message bypass augmentation
  - [ ] Test that non-ambiguous queries bypass augmentation
- [ ] Verify original user message preservation (AC: 7)
  - [ ] Test that LLM receives original user message (not augmented query)
  - [ ] Test that chat history saves original user message
  - [ ] Test that user sees original message in conversation
- [ ] Verify HybridSearchService integration (AC: 8)
  - [ ] Test that augmented query triggers section-ID direct path
  - [ ] Test that correct chunks are retrieved for section from history
  - [ ] Test that existing section-ID queries continue to work
- [ ] Verify API compatibility (AC: 9)
  - [ ] Test that ChatRequest schema unchanged
  - [ ] Test that ChatResponse schema unchanged
  - [ ] Test that API endpoint paths unchanged
  - [ ] Test backward compatibility with existing clients
- [ ] Verify chat history mechanism (AC: 10)
  - [ ] Test that ChatSession/ChatMessage models unchanged
  - [ ] Test that load_history() continues to work
  - [ ] Test that save_turn() continues to work
  - [ ] Test that conversation_id/session_id handling unchanged
- [ ] Create unit tests for helper methods (AC: 11)
  - [ ] Test \_extract_section_id with various patterns
  - [ ] Test \_is_ambiguous_followup with various queries
  - [ ] Test \_get_last_section_id_from_history with various history scenarios
  - [ ] Test \_build_retrieval_query with various combinations
- [ ] Create integration test (AC: 12)
  - [ ] Test: Turn 1 - "what's in section 5.22.3" → successful retrieval
  - [ ] Test: Turn 2 - "what do I need to submit for this?" (same session) → verify HybridSearchService receives query containing "5.22.3"
  - [ ] Test: Verify correct chunks retrieved for section 5.22.3
  - [ ] Test: Verify LLM receives original user message "what do I need to submit for this?"

## Dev Notes

### Previous Story Insights

From Story 12.1 (Multi-turn Chat History Backend):

- ChatOrchestrator.load_history() returns list of message dicts: `[{"role": "user", "content": "..."}, ...]`
- History is ordered chronologically (oldest first)
- History limit is 10 messages (5 turns) by default
- Session management via UUID strings (frontend) mapped to Integer IDs (database)

From Story 12.2 (Multi-turn Chat History Frontend):

- Frontend maintains session_id in localStorage
- Frontend sends optional conversation_id in ChatRequest
- Backend returns session_id in ChatResponse

From Story 11 (Section-ID Query Improvements):

- HybridSearchService.search() has section-ID direct path that detects patterns like `5.22.3`
- Uses regex: `r'\d+(?:\.\d+)+'` to extract section IDs
- Direct DB lookup for section_id and section_id_alias
- Parent section fallback if exact match not found
- This path is triggered when section ID pattern is present in query string

### Implementation Approach

**Key Design Decision:**

- Do NOT modify HybridSearchService.search() behavior
- Instead, augment the query string passed to it
- This ensures the existing section-ID direct path is triggered for follow-up questions

**Flow Modification:**

Current flow in `app/api/routes/chat.py`:

1. `retrieve_candidates(chat_request.message)` - uses raw user message
2. `rerank(chat_request.message, candidates)`
3. `chat(chat_request.message, reranked, session_id)`

Updated flow:

1. Load history: `history = chat_orchestrator.load_history(session_id, limit=10)`
2. Build retrieval query: `retrieval_query = chat_orchestrator._build_retrieval_query(history, chat_request.message)`
3. `retrieve_candidates(retrieval_query)` - uses augmented query
4. `rerank(chat_request.message, candidates)` - still uses original message
5. `chat(chat_request.message, reranked, session_id)` - still uses original message

**Helper Method Specifications:**

```python
def _extract_section_id(self, text: str) -> Optional[str]:
    """
    Extract section ID pattern from text (e.g., 5.22.3)

    Args:
        text: Text to search for section ID pattern

    Returns:
        Section ID string (e.g., "5.22.3") or None if not found
    """
    # Use same regex as HybridSearchService: r'\d+(?:\.\d+)+'
    section_id_pattern = re.search(r'\d+(?:\.\d+)+', text)
    return section_id_pattern.group(0) if section_id_pattern else None

def _is_ambiguous_followup(self, query: str) -> bool:
    """
    Detect if query is an ambiguous follow-up that needs section context

    Args:
        query: User query string

    Returns:
        True if query is short, contains pronouns, and lacks explicit section ID
    """
    query_lower = query.lower()

    # Check length (short queries more likely to be follow-ups)
    is_short = len(query) < 80  # Character threshold

    # Check for pronouns/phrases
    pronouns = ["this", "that", "it", "them", "those"]
    phrases = ["for this", "for that", "for it", "for these", "for those"]
    has_pronoun = any(pronoun in query_lower for pronoun in pronouns) or \
                  any(phrase in query_lower for phrase in phrases)

    # Check if explicit section ID is present
    has_section_id = self._extract_section_id(query) is not None

    # Ambiguous if: short AND has pronoun AND no explicit section ID
    return is_short and has_pronoun and not has_section_id

def _get_last_section_id_from_history(self, history_messages: List[Dict[str, str]]) -> Optional[str]:
    """
    Find the most recent section ID from chat history

    Args:
        history_messages: List of message dicts from load_history()

    Returns:
        Most recent section ID string or None if not found
    """
    # Iterate backwards (most recent first)
    for msg in reversed(history_messages):
        if msg.get("role") == "user":
            section_id = self._extract_section_id(msg.get("content", ""))
            if section_id:
                return section_id
    return None

def _build_retrieval_query(self, history_messages: List[Dict[str, str]], current_user_message: str) -> str:
    """
    Build effective retrieval query, augmenting ambiguous follow-ups with section context

    Args:
        history_messages: List of message dicts from load_history()
        current_user_message: Current user query string

    Returns:
        Query string for retrieval (may be augmented or unchanged)
    """
    # If current message has explicit section ID, use as-is
    if self._extract_section_id(current_user_message):
        return current_user_message

    # If not ambiguous follow-up, use as-is
    if not self._is_ambiguous_followup(current_user_message):
        return current_user_message

    # Ambiguous follow-up: try to get section ID from history
    last_section_id = self._get_last_section_id_from_history(history_messages)
    if last_section_id:
        # Augment query with section context
        augmented = f"For section {last_section_id}, {current_user_message}"
        logger.info(f"Augmented retrieval query with section {last_section_id}: {augmented}")
        return augmented

    # No section ID in history, use as-is
    return current_user_message
```

### API Specifications

**No API Changes Required:**

- ChatRequest schema: unchanged (conversation_id optional, message required)
- ChatResponse schema: unchanged (session_id, answer, citations, latency_ms)
- API endpoint: POST `/api/chat` - unchanged
- Request/response formats: unchanged

**Internal Flow Changes:**

- Retrieval query is augmented internally before calling HybridSearchService
- Original user message is preserved for LLM and history
- Changes are transparent to API consumers

### Component Specifications

**ChatOrchestrator Updates:**

- Add four private helper methods (as specified above)
- No changes to public methods (chat(), load_history(), save_turn(), etc.)
- Helpers are internal implementation details

**Chat API Route Updates:**

- Load history before retrieval (if session_id provided)
- Build retrieval query using helper
- Use augmented query for retrieval only
- Preserve original message for rerank and LLM

**HybridSearchService:**

- No changes required
- Existing section-ID direct path will be triggered by augmented queries
- Regex pattern matching will detect section IDs in augmented queries

### File Locations

**Files to Modify:**

- `app/services/chat_orchestrator.py` - Add helper methods
- `app/api/routes/chat.py` - Update retrieval flow to use augmented query

**Files to Create:**

- `tests/unit/test_chat_orchestrator_followup.py` - Unit tests for helper methods
- `tests/integration/test_followup_aware_retrieval.py` - Integration tests

### Technical Constraints

**No Breaking Changes:**

- Public API routes unchanged
- Request/response schemas unchanged
- ChatSession/ChatMessage models unchanged
- Existing multi-turn chat history mechanism unchanged

**Retrieval Grounding:**

- Retrieval must remain document-grounded
- Only the query string is augmented, not the retrieval mechanism
- HybridSearchService behavior unchanged

**Section-ID Direct Path:**

- Existing section-ID detection in HybridSearchService uses: `r'\d+(?:\.\d+)+'`
- Augmented queries will contain section IDs in format: "For section 5.22.3, what do I need to submit for this?"
- This format will trigger the existing section-ID direct path

**History Management:**

- History loading uses existing load_history() method
- History limit: 10 messages (5 turns) - unchanged
- History format: `[{"role": "user", "content": "..."}, ...]` - unchanged

### Testing Requirements

**Test File Location:**

- Unit tests: `tests/unit/test_chat_orchestrator_followup.py`
- Integration tests: `tests/integration/test_followup_aware_retrieval.py`

**Testing Framework:**

- pytest with existing test patterns
- Mock HybridSearchService.search() to capture query strings
- Use test database for integration tests

**Test Coverage:**

**Unit Tests for \_extract_section_id:**

- Extract "5.22.3" from "what's in section 5.22.3"
- Extract "1.2" from "explain section 1.2"
- Extract "10.5.3.2" from complex section IDs
- Return None for text without section IDs
- Return None for invalid patterns

**Unit Tests for \_is_ambiguous_followup:**

- "what do I need to submit for this?" → True
- "what are the indicators for it?" → True
- "explain section 5.22.3" → False (explicit section)
- "give me an overview of the framework" → False (no pronouns, longer)
- "what is the evidence for this section?" → False (contains section ID)

**Unit Tests for \_get_last_section_id_from_history:**

- History with section ID in last user message → returns section ID
- History with section ID in earlier user message → returns most recent
- History without section IDs → returns None
- Empty history → returns None
- History with only assistant messages → returns None

**Unit Tests for \_build_retrieval_query:**

- Current message has explicit section ID → returns unchanged
- Non-ambiguous query → returns unchanged
- Ambiguous follow-up with history section ID → returns augmented query
- Ambiguous follow-up without history section ID → returns unchanged
- Various edge cases

**Integration Tests:**

- Turn 1: "what's in section 5.22.3" → successful
- Turn 2: "what do I need to submit for this?" → verify HybridSearchService receives query with "5.22.3"
- Verify correct chunks retrieved for section 5.22.3
- Verify LLM receives original message "what do I need to submit for this?"
- Verify history saved with original message (not augmented query)

### Integration Requirements

**History Loading:**

- Must load history before building retrieval query
- Use existing load_history() method
- Handle empty history gracefully (no augmentation if no section ID)

**Retrieval Integration:**

- Augmented query passed to retrieve_candidates()
- retrieve_candidates() calls HybridSearchService.search()
- HybridSearchService detects section ID in augmented query
- Section-ID direct path triggered automatically

**LLM Integration:**

- Original user message passed to chat() method
- Original message included in LLM context
- Original message saved to history
- Augmentation is transparent to LLM

### Project Structure Notes

The project follows clear separation:

- Services in `app/services/` (chat_orchestrator.py, hybrid_search.py)
- API routes in `app/api/routes/` (chat.py)
- Tests in `tests/unit/` and `tests/integration/`

Helper methods are private (prefixed with `_`) as they are internal implementation details.

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## Change Log

| Date       | Version | Description            | Author           |
| ---------- | ------- | ---------------------- | ---------------- |
| 2025-11-24 | 1.0     | Initial story creation | Sarah (PO Agent) |
